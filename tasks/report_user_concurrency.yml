---
# Report-only per-user-per-IP concurrency using current sockets + last /live request

# Defaults you can set in role defaults/vars as needed
- name: "Report Concurrency | Set defaults"
  ansible.builtin.set_fact:
    __nginx_access_log: "{{ role_iptvservice__nginx_access_log | default('/var/log/nginx/yiafe_access.log') }}"
    __default_user_cap: "{{ role_iptvservice__default_max_connections | default(2) }}"

# 1) Get current established client connections to Nginx :80
- name: "Report Concurrency | ss :80 established"
  ansible.builtin.command:
    cmd: ss -Htn sport = :80 state established
  register: __ss80
  changed_when: false
  failed_when: false

# 2) Extract client IPv4s from ss output
- name: "Report Concurrency | Extract client IPv4s"
  ansible.builtin.set_fact:
    __client_ips: >-
      {{
        __ss80.stdout
        | regex_findall('\\S+:80\\s+(\\d+\\.\\d+\\.\\d+\\.\\d+):\\d+', multiline=True)
        | unique
      }}

# 3) Tail recent access log for quick lookup
- name: "Report Concurrency | Tail nginx access log"
  ansible.builtin.command:
    cmd: tail -n 100000 "{{ __nginx_access_log }}"
  register: __log_tail
  changed_when: false
  failed_when: false

# 4) For each IP, find their most recent /live/... line and extract the proxy username
#    Handles both:
#     - /live/<user>/<pass>/<id>...
#     - /<USERNAME>/live/<user>/<pass>/<id>...
- name: "Report Concurrency | Build (user,ip) pairs from log"
  ansible.builtin.set_fact:
    __user_ip_pairs: >-
      {%- set out = [] -%}
      {%- for ip in __client_ips | default([]) -%}
        {%- set lines = (__log_tail.stdout_lines | default([])) | select('match', '^' ~ ip ~ ' ') | select('search', '/live/') | list -%}
        {%- set last = (lines | last | default('')) -%}
        {%- set u = (last | regex_findall('/(?:[^/]+/)?live/([^/]+)/') | last | default('')) -%}
        {%- if u | length > 0 -%}
          {%- set _ = out.append({'user': u, 'ip': ip}) -%}
        {%- endif -%}
      {%- endfor -%}
      {{ out }}

# 5) Count concurrent connections per (user,ip)
- name: "Report Concurrency | Count connections per user+ip"
  ansible.builtin.set_fact:
    __counts_by_key: >-
      {{
        (__user_ip_pairs | map('json_query', 'user') | list) | length
        | ternary(
            (__user_ip_pairs | map('combine', {'key': (item.user ~ '|' ~ item.ip)}) | list),
            []
          )
      }}
  vars:
    item: "{{ omit }}"   # noop; helper var

# Build a simple list of "user|ip" to feed into counter
- name: "Report Concurrency | Flatten keys for counter"
  ansible.builtin.set_fact:
    __keys_flat: "{{ __user_ip_pairs | map('regex_replace', '^(.*)$', attribute=0) | list }}"
  vars:
    # map helper not available; build strings explicitly
    __user_ip_pairs_str: >-
      {{
        __user_ip_pairs | map('json_query', 'user') | list
      }}

# Actually create keys list correctly
- name: "Report Concurrency | Compose keys list"
  ansible.builtin.set_fact:
    __keys: "{{ __user_ip_pairs | map('extract', ['user', 'ip']) | list | map('join', '|') | list }}"

- name: "Report Concurrency | Counter by (user|ip)"
  ansible.builtin.set_fact:
    __key_counts: "{{ __keys | community.general.counter }}"

# 6) Build overages list comparing against per-user caps (__users dict or default)
- name: "Report Concurrency | Detect overages"
  ansible.builtin.set_fact:
    __overages: >-
      {%- set out = [] -%}
      {%- for k, v in (__key_counts | default({})).items() -%}
        {%- set parts = k.split('|') -%}
        {%- set u = parts[0] -%}
        {%- set ip = parts[1] if parts|length > 1 else 'unknown' -%}
        {%- set cap = (__users.get(u, {}).get('max_connections', __default_user_cap)) | int -%}
        {%- if (v | int) > cap -%}
          {%- set _ = out.append({'user': u, 'ip': ip, 'count': v | int, 'cap': cap}) -%}
        {%- endif -%}
      {%- endfor -%}
      {{ out }}

# 7) Render a small text report (only if anything exceeded)
- name: "Report Concurrency | Compose mail body"
  ansible.builtin.set_fact:
    __mail_body: |
      Per-user concurrency overages (observed via active sockets to :80 and latest /live/ request):
      {% for o in __overages %}
      - user: {{ o.user }}  ip: {{ o.ip }}  connections: {{ o.count }}  cap: {{ o.cap }}
      {% endfor %}
  when: (__overages | length) > 0

- name: "Report Concurrency | Email overages"
  when: (__overages | length) > 0
  community.general.mail:
    from: "{{ role_iptvservice__email_sender }}"
    to: "{{ role_iptvservice__email_recipients }}"
    subject: "IPTV concurrency over cap (per-user per-IP)"
    host: "{{ role_iptvservice__email_server }}"
    port: 25
    secure: never
    body: "{{ __mail_body }}"
