#!/usr/bin/env python3
import os, json, base64, logging, hashlib, re
from typing import Any, Dict, Optional, Tuple
from flask import Flask, request, Response

AUTH_ROOT = os.environ.get("IPTV_AUTH_ROOT", "/opt/iptv-auth")
USERS_JSON = os.path.join(AUTH_ROOT, "users.json")
BACKENDS_JSON = os.path.join(AUTH_ROOT, "backends.json")

# Where to send viewers if live==false and they request a channel segment:
OOS_REDIRECT_URL = os.environ.get(
    "IPTV_AUTH_OOS_URL",
    "https://{{ (role_iptvservice__iptv_hostname | first) | trim }}/oos.ts"
)

# iptv-proxy runs locally on these ports
BACKEND_HOST = os.environ.get("IPTV_PROXY_HOST", "127.0.0.1")
BACKEND_SCHEME = os.environ.get("IPTV_PROXY_SCHEME", "http")

LOG_LEVEL = os.environ.get("IPTV_AUTH_LOG", "{{ (role_iptvservice__auth_log_level | default('INFO')) | upper }}").upper()
logging.basicConfig(level=getattr(logging, LOG_LEVEL, logging.INFO),
                    format="%(asctime)s %(levelname)s %(message)s")

app = Flask(__name__)

# Only treat real channel segments as "live playback" (.ts). Supports optional /USERNAME prefix.
CHAN_RE = re.compile(r"^/(?:[^/]+/)?live/[^/]+/[^/]+/\d+\.ts(?:\?.*)?$", re.IGNORECASE)

def _load_json(path: str) -> Any:
    with open(path, "r", encoding="utf-8") as f:
        return json.load(f)

def _safe_bool(v: Any, default: bool = True) -> bool:
    if isinstance(v, bool): return v
    if v is None: return default
    s = str(v).strip().lower()
    if s in ("1","true","yes","y","on"): return True
    if s in ("0","false","no","n","off"): return False
    return default

def _parse_basic(auth: Optional[str]) -> Tuple[Optional[str], Optional[str]]:
    if not auth: return None, None
    try:
        scheme, blob = auth.split(" ", 1)
        if scheme.lower() != "basic": return None, None
        raw = base64.b64decode(blob.strip()).decode("utf-8", errors="ignore")
        if ":" not in raw: return None, None
        u, p = raw.split(":", 1)
        return u, p
    except Exception:
        return None, None

def _extract_creds() -> Tuple[Optional[str], Optional[str], str]:
    # 1) Basic from client
    hu, hp = _parse_basic(request.headers.get("Authorization"))
    # 2) Query
    qu = request.args.get("username") or request.args.get("user")
    qp = request.args.get("password") or request.args.get("pass")
    # 3) Exact request path (nginx sets X-Original-URI)
    original_uri = request.headers.get("X-Original-URI") or request.full_path or request.path
    path_only = original_uri.split("?", 1)[0]
    user = hu or qu
    pw   = hp or qp
    return user, pw, path_only

def _map_backend(user: str, backends: list[Dict[str, Any]]) -> Dict[str, Any]:
    if len(backends) <= 1:
        return backends[0]
    h = hashlib.md5(user.encode("utf-8")).hexdigest()
    idx = int(h, 16) % len(backends)
    return backends[idx]

def _basic_blob(u: str, p: str) -> str:
    return "Basic " + base64.b64encode(f"{u}:{p}".encode("utf-8")).decode("ascii")

# Load config (once)
try:
    USERS = _load_json(USERS_JSON)
except Exception as e:
    logging.error("load %s failed: %s", USERS_JSON, e)
    USERS = {}

try:
    RAW_BACKENDS = _load_json(BACKENDS_JSON)
except Exception as e:
    logging.error("load %s failed: %s", BACKENDS_JSON, e)
    RAW_BACKENDS = []

BACKENDS = []
for b in RAW_BACKENDS:
    port = int(b["port"])
    BACKENDS.append({
        **b,
        "base": f"{BACKEND_SCHEME}://{BACKEND_HOST}:{port}"
    })

@app.route("/healthz", methods=["GET"])
def healthz():
    return Response("ok\n", 200, mimetype="text/plain")

@app.route("/auth", methods=["GET"])
def auth():
    user, pw, path_only = _extract_creds()
    logging.info("auth start: user=%s path=%s", user or "-", path_only)

    if not user or user not in USERS:
        return Response(status=401)
    rec = USERS[user]
    expect = str(rec.get("password", ""))
    if pw and pw != expect:
        return Response(status=401)

    live_on = _safe_bool(rec.get("live", True), True)
    # vod_on = _safe_bool(rec.get("vod", True), True)  # (available if you later want to gate VOD similarly)

    # If live is OFF and this is a real channel segment, ask nginx to 302 the client to OOS.
    if not live_on and CHAN_RE.match(path_only or ""):
        logging.info("live disabled for %s -> redirect %s", user, OOS_REDIRECT_URL)
        resp = Response(status=403)
        resp.headers["X-Redirect"] = OOS_REDIRECT_URL
        resp.headers["X-Live-Disabled"] = "1"
        return resp

    # OK â†’ pick backend and give nginx the upstream + credentials to use
    if not BACKENDS:
        return Response(status=503)
    be = _map_backend(user, BACKENDS)

    resp = Response(status=200)
    resp.headers["X-Backend"]      = be["base"]
    resp.headers["X-Basic"]        = _basic_blob(be["proxy_user"], be["proxy_pass"])
    resp.headers["X-Proxy-User"]   = be["proxy_user"]
    resp.headers["X-Proxy-Pass"]   = be["proxy_pass"]
    resp.headers["X-Display-User"] = user
    return resp

if __name__ == "__main__":
    app.run(host="127.0.0.1", port=9100)
