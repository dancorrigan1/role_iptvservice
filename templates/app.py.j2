#!/usr/bin/env python3
import base64
import json
import logging
import os
import re
import fcntl
import random
from typing import Any, Dict, List, Optional, Tuple
from flask import Flask, request, Response

APP_PORT   = {{ role_iptvservice__auth_port }}
AUTH_ROOT  = "{{ role_iptvservice__auth_root }}"
USERS_PATH = os.path.join(AUTH_ROOT, "users.json")
BACKENDS_PATH = os.path.join(AUTH_ROOT, "backends.json")
USER_BACKENDS_PATH = os.path.join(AUTH_ROOT, "user_backends.json")

DESIRED_EXT = "{{ role_iptvservice__desired_ext }}"
# Where to send viewers if live==false and they request a channel segment:
OOS_URL = {{ (role_iptvservice__oos_url | default('https://' + (role_iptvservice__iptv_hostname | first) + '/oos.ts')) | tojson }}

# Match real channel **segments** (only .ts), with or without /USERNAME prefix:
#   /live/<u>/<p>/<id>.ts
#   /<USERNAME>/live/<u>/<p>/<id>.ts
CHAN_TS_RE = re.compile(r"^/(?:[^/]+/)?live/[^/]+/[^/]+/\d+\.ts(?:\?.*)?$", re.IGNORECASE)

LOG_LEVEL = "{{ (role_iptvservice__auth_log_level | default('INFO')) | upper }}"
logging.basicConfig(level=getattr(logging, LOG_LEVEL, logging.INFO),
                    format="%(asctime)s %(levelname)s %(message)s")

app = Flask(__name__)

def load_json(path: str, default: Any) -> Any:
    try:
        with open(path, "r", encoding="utf-8") as f:
            return json.load(f)
    except Exception:
        return default

USERS: Dict[str, Dict[str, Any]] = load_json(USERS_PATH, {})
BACKENDS: List[Dict[str, Any]] = load_json(BACKENDS_PATH, [])
USER_BACKENDS: Dict[str, str] = load_json(USER_BACKENDS_PATH, {})

def pick_backend_for_user(username: str) -> Optional[Dict[str, Any]]:
    """
    Prefer a backend whose 'provider' matches the user's provider from users.json.
    Within that pool, choose the backend with the lowest load ratio
    (active_cons / max_connections) when this information is available.
    If no matching backends exist, fall back to the full list.
    Selection among equally loaded backends is random, but if the user has a
    previously selected backend that still has capacity it will be reused.
    Reload backend metadata under a file lock so routing decisions reflect
    current connection counts even with concurrent workers. Log the score for
    every candidate and the chosen backend for observability.
    """
    global BACKENDS, USER_BACKENDS
    user_provider = ""
    scores: List[Tuple[Dict[str, Any], float]] = []
    choice: Optional[Dict[str, Any]] = None
    try:
        with open(BACKENDS_PATH, "r+", encoding="utf-8") as f:
            try:
                uf = open(USER_BACKENDS_PATH, "r+", encoding="utf-8")
            except FileNotFoundError:
                uf = open(USER_BACKENDS_PATH, "w+", encoding="utf-8")
            with uf:
                fcntl.flock(f, fcntl.LOCK_EX)
                fcntl.flock(uf, fcntl.LOCK_EX)
                uf.seek(0)
                try:
                    BACKENDS = json.load(f)
                except Exception:
                    BACKENDS = []
                try:
                    USER_BACKENDS = json.load(uf)
                except Exception:
                    USER_BACKENDS = {}
                if not BACKENDS:
                    return None

                user_info = USERS.get(username, {})
                user_provider = (user_info.get("provider") or "").strip()
                pool = [b for b in BACKENDS if (b.get("provider") or "").strip() == user_provider] if user_provider else []
                if not pool:
                    pool = BACKENDS

                def load_ratio(b: Dict[str, Any]) -> float:
                    try:
                        cur = int(b.get("active_cons") or 0)
                        maxc = int(b.get("max_connections") or 0)
                        if maxc > 0:
                            return cur / maxc
                    except Exception:
                        pass
                    return 1.0  # treat unknown as fully loaded

                def has_capacity(b: Dict[str, Any]) -> bool:
                    try:
                        cur = int(b.get("active_cons") or 0)
                        maxc = int(b.get("max_connections") or 0)
                        return maxc <= 0 or cur < maxc
                    except Exception:
                        return True

                scores = [(b, load_ratio(b)) for b in pool]

                last_name = USER_BACKENDS.get(username)
                if last_name:
                    for b in pool:
                        if b.get("name") == last_name and has_capacity(b):
                            choice = b
                            break

                if choice is None:
                    available_scores = [(b, s) for b, s in scores if has_capacity(b)]
                    if not available_scores:
                        available_scores = scores
                    min_load = min(s for _, s in available_scores)
                    candidates = [b for b, s in available_scores if s == min_load]
                    choice = random.choice(candidates)

                choice["active_cons"] = int(choice.get("active_cons") or 0) + 1
                USER_BACKENDS[username] = choice.get("name")
                f.seek(0)
                json.dump(BACKENDS, f, indent=2)
                f.truncate()
                uf.seek(0)
                json.dump(USER_BACKENDS, uf, indent=2)
                uf.truncate()
    except Exception:
        return None

    logging.info(
        "backend scores user=%s provider=%s %s -> %s %.3f",
        username,
        user_provider or "-",
        " ".join(f"{b['name']}={s:.3f}" for b, s in scores),
        choice.get("name") if choice else "-",
        next((s for b, s in scores if b is choice), 0.0) if choice else 0.0,
    )

    return choice

def parse_basic(auth_header: Optional[str]) -> Tuple[Optional[str], Optional[str]]:
    if not auth_header or not auth_header.lower().startswith("basic "):
        return (None, None)
    try:
        raw = base64.b64decode(auth_header.split(None, 1)[1]).decode("utf-8", errors="ignore")
        u, p = raw.split(":", 1)
        return (u, p)
    except Exception:
        return (None, None)

def truthy(v, default=True):
    if isinstance(v, bool):
        return v
    if v is None:
        return default
    s = str(v).strip().lower()
    if s in ("1","true","yes","y","on"):  return True
    if s in ("0","false","no","n","off"): return False
    return default

@app.route("/healthz")
def healthz():
    return "ok", 200

@app.route("/auth")
def auth():
    # Inputs from nginx (set in /_auth)
    x_user = request.headers.get("X-Q-User", "").strip()
    x_pass = request.headers.get("X-Q-Pass", "").strip()
    x_path_user = request.headers.get("X-Path-User", "").strip()
    orig_args = request.headers.get("X-Orig-Args", "")
    req_uri   = request.headers.get("X-Req-URI", "")  # full request_uri (for /live/...ts detection)

    global USERS
    USERS = load_json(USERS_PATH, USERS)

    # Query fallback
    q_user = (request.args.get("username") or "").strip()
    q_pass = (request.args.get("password") or "").strip()

    # Basic auth
    b_user, b_pass = parse_basic(request.headers.get("Authorization"))

    # pick first present: basic > query > header > path
    user   = next((x for x in [b_user, q_user, x_user, x_path_user] if x), "")
    passwd = next((x for x in [b_pass, q_pass, x_pass] if x), "")

    # validate user
    rec = USERS.get(user)
    if not user or rec is None:
        logging.info("auth 401 for user=%s", user or "-")
        return Response(status=401)
    if passwd != str(rec.get("password", "")):
        logging.info("auth 401 bad pass for user=%s", user)
        return Response(status=401)

    # If live==false and this exact request is for a .ts channel segment, instruct nginx to 302 to OOS_URL.
    live_on = truthy(rec.get("live", True), True)
    if (not live_on) and req_uri and CHAN_TS_RE.match(req_uri):
        logging.info("live disabled for %s -> redirect %s (req=%s)", user, OOS_URL, req_uri)
        resp = Response(status=403)                  # auth_request sees 403 â†’ @auth_fail handler 302s to X-Redirect
        resp.headers["X-Redirect"] = OOS_URL
        return resp

    # choose backend (provider-aware)
    be = pick_backend_for_user(user)
    if not be:
        logging.info("auth 503 no backends")
        return Response(status=503)

    backend = f"http://127.0.0.1:{be['port']}"

    # Build forward args for upstream: keep client's args but force upstream creds
    extras = []
    if orig_args:
        for kv in orig_args.split("&"):
            if not kv:
                continue
            k = kv.split("=",1)[0]
            if k in ("username","password"):
                continue
            extras.append(kv)
    extras.append(f"username={be['proxy_user']}")
    extras.append(f"password={be['proxy_pass']}")
    rewrite_args = "&".join(extras)

    headers = {
        "X-Backend": backend,
        "X-Basic": "Basic " + base64.b64encode(f"{be['proxy_user']}:{be['proxy_pass']}".encode()).decode(),
        "X-Proxy-User": be["proxy_user"],
        "X-Proxy-Pass": be["proxy_pass"],
        "X-Display-User": user,
        "X-Display-Pass": passwd,
        "X-Rewrite-Args": rewrite_args,
        "X-Host": request.host.split(":")[0],
        "X-Desired-Ext": DESIRED_EXT,
    }

    logging.info("auth 200 user=%s provider=%s backend=%s port=%s live=%s req=%s",
                 user, rec.get("provider","-"), be.get("name"), be.get("port"), live_on, req_uri or "-")
    return Response(status=200, headers=headers)

if __name__ == "__main__":
    app.run(host="127.0.0.1", port=APP_PORT)
