#!/usr/bin/env python3
import os, json, base64, logging, hashlib
from typing import Any, Dict, Optional, Tuple
from flask import Flask, request, Response

AUTH_ROOT     = os.environ.get("IPTV_AUTH_ROOT", "/opt/iptv-auth")
USERS_JSON    = os.path.join(AUTH_ROOT, "users.json")
BACKENDS_JSON = os.path.join(AUTH_ROOT, "backends.json")

OOS_REDIRECT_URL = os.environ.get(
    "IPTV_AUTH_OOS_URL",
    "https://{{ (role_iptvservice__iptv_hostname | first) | trim }}/oos.ts"
)

BACKEND_HOST   = os.environ.get("IPTV_PROXY_HOST", "127.0.0.1")
BACKEND_SCHEME = os.environ.get("IPTV_PROXY_SCHEME", "http")

LOG_LEVEL = os.environ.get("IPTV_AUTH_LOG", "{{ (role_iptvservice__auth_log_level | default('INFO')) | upper }}").upper()
logging.basicConfig(level=getattr(logging, LOG_LEVEL, logging.INFO),
                    format="%(asctime)s %(levelname)s %(message)s")
app = Flask(__name__)

def _load_json(path: str) -> Any:
    with open(path, "r", encoding="utf-8") as f:
        return json.load(f)

def _safe_bool(v: Any, default: bool=True) -> bool:
    if isinstance(v, bool): return v
    if v is None: return default
    s = str(v).strip().lower()
    if s in ("1","true","yes","y","on"):  return True
    if s in ("0","false","no","n","off"): return False
    return default

def _parse_basic(auth: Optional[str]) -> Tuple[Optional[str], Optional[str]]:
    if not auth: return None, None
    try:
        scheme, blob = auth.split(" ", 1)
        if scheme.lower() != "basic": return None, None
        raw = base64.b64decode(blob.strip()).decode("utf-8", errors="ignore")
        if ":" not in raw: return None, None
        u, p = raw.split(":", 1)
        return u, p
    except Exception:
        return None, None

def _extract_userpass() -> Tuple[Optional[str], Optional[str]]:
    # order: Authorization header, then query args (sent by nginx in subrequest)
    hu, hp = _parse_basic(request.headers.get("Authorization"))
    qu = request.args.get("username") or request.args.get("user")
    qp = request.args.get("password") or request.args.get("pass")
    return (hu or qu, hp or qp)

def _map_backend(user: str, backends: list[Dict[str, Any]]) -> Dict[str, Any]:
    if not backends:
        return {}
    if len(backends) == 1:
        return backends[0]
    h = hashlib.md5(user.encode("utf-8")).hexdigest()
    idx = int(h, 16) % len(backends)
    return backends[idx]

def _basic_blob(u: str, p: str) -> str:
    return "Basic " + base64.b64encode(f"{u}:{p}".encode("utf-8")).decode("ascii")

# ---- load config once ----
try:
    USERS = _load_json(USERS_JSON)
except Exception as e:
    logging.error("load %s failed: %s", USERS_JSON, e)
    USERS = {}

try:
    RAW_BACKENDS = _load_json(BACKENDS_JSON)
except Exception as e:
    logging.error("load %s failed: %s", BACKENDS_JSON, e)
    RAW_BACKENDS = []

BACKENDS = []
for b in RAW_BACKENDS:
    port = int(b["port"])
    BACKENDS.append({
        **b,
        "base": f"{BACKEND_SCHEME}://{BACKEND_HOST}:{port}",
    })

def _auth_core(enforce_live: bool) -> Response:
    user, pw = _extract_userpass()
    logging.info("auth start: enforce_live=%s user=%s", enforce_live, user or "-")

    if not user or user not in USERS:
        return Response(status=401)

    rec = USERS[user]
    expect = str(rec.get("password", ""))
    if pw and pw != expect:
        return Response(status=401)

    if enforce_live and not _safe_bool(rec.get("live", True), True):
        # tell nginx to 302 the segment to oos.ts
        resp = Response(status=403)
        resp.headers["X-Redirect"] = OOS_REDIRECT_URL
        resp.headers["X-Live-Disabled"] = "1"
        return resp

    if not BACKENDS:
        return Response(status=503)

    be = _map_backend(user, BACKENDS)
    if not be:
        return Response(status=503)

    resp = Response(status=200)
    resp.headers["X-Backend"]      = be["base"]
    resp.headers["X-Basic"]        = _basic_blob(be["proxy_user"], be["proxy_pass"])
    resp.headers["X-Proxy-User"]   = be["proxy_user"]
    resp.headers["X-Proxy-Pass"]   = be["proxy_pass"]
    resp.headers["X-Display-User"] = user
    return resp

@app.route("/healthz", methods=["GET"])
def healthz():
    return Response("ok\n", 200, mimetype="text/plain")

# used for login, metadata, vod etc
@app.route("/auth", methods=["GET"])
def auth():
    return _auth_core(enforce_live=False)

# used only for channel segment (.ts/.m3u8) requests
@app.route("/auth_live", methods=["GET"])
def auth_live():
    return _auth_core(enforce_live=True)

if __name__ == "__main__":
    app.run(host="127.0.0.1", port=9100)
